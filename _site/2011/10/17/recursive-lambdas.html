<p>I ran into a case where I wanted a recursive lambda and decided to capture some things I learned during my research. I found that there&#8217;s a couple ways of approaching this, the more &#8216;pure&#8217; way is using a Y-combinator approach, that uses a self-application function to grab the function you&#8217;ll be recursing. The other way, and the way I ultimately went, was using the Ruby 1.9 Object#tap method to grab the function you&#8217;ll be recursing. The Y-combinator approach is more abstract and brain-expanding, so I covered that first. However, if pragmatism is the goal, feel free to skip to the Object#tap section.</p>

<p>While investigating recursive lambdas, a google search led me to Nathan Weizenbaum&#8217;s <a href='http://nex-3.com/'>blog</a> post on <a href='http://nex-3.com/posts/43-fun-with-the-y-combinator-in-ruby'>Fun with the Y Combinator</a>. He has an excellent write up of this problem in general. However, since I always seem to need to refresh my brain on how to think about recursion, there were bits of his post that I struggled to fully comprehend. One bit in particular is this wonderful line of code known as the self-application function.</p>
<div class='highlight'><pre><code class='ruby'>     <span class='nb'>lambda</span><span class='p'>{</span><span class='o'>|</span><span class='n'>f</span><span class='o'>|</span> <span class='n'>f</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>f</span><span class='p'>)}</span>
</code></pre>
</div>
<p>Or in the more familiar, non-anonymous, method forms</p>
<div class='highlight'><pre><code class='ruby'>    <span class='c1'>#block/yield version</span>
    <span class='k'>def</span> <span class='nf'>self_app</span> <span class='o'>&amp;</span><span class='n'>f</span>
      <span class='k'>yield</span> <span class='n'>f</span>
    <span class='k'>end</span>
</code></pre>
</div><div class='highlight'><pre><code class='ruby'>    <span class='c1'>#callable block as the parameter</span>
    <span class='k'>def</span> <span class='nf'>self_app</span><span class='p'>(</span><span class='n'>f</span><span class='p'>)</span>
      <span class='n'>f</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>f</span><span class='p'>)</span>
    <span class='k'>end</span>
</code></pre>
</div>
<p>So what does it do? Well first notice that what we pass into it must be a function since we&#8217;re going to be calling it. Second, notice that this function must accept a single parameter, and that parameter will be the very same function. To illustrate let&#8217;s create a function, <code> g </code></p>
<div class='highlight'><pre><code class='ruby'>    <span class='n'>g</span> <span class='o'>=</span> <span class='nb'>lambda</span><span class='p'>{</span><span class='s2'>&quot;Hello Lambda World&quot;</span><span class='p'>}</span>
</code></pre>
</div>
<p>Can we pass this function to the self-application function? No, because it&#8217;s doesn&#8217;t have parameter for the self-application function (<code>f</code>) being passed to it. Let&#8217;s fix that.</p>
<div class='highlight'><pre><code class='ruby'>    <span class='n'>g</span> <span class='o'>=</span> <span class='nb'>lambda</span><span class='p'>{</span><span class='o'>|</span><span class='n'>me</span><span class='o'>|</span> <span class='s2'>&quot;Hello Lambda World from </span><span class='si'>#{</span><span class='n'>me</span><span class='o'>.</span><span class='n'>inspect</span><span class='si'>}</span><span class='s2'>&quot;</span><span class='p'>}</span>
</code></pre>
</div>
<p>and apply the self-app function, with the self-app function assigned to <code>f</code> for brevity and convenience.</p>
<div class='highlight'><pre><code class='ruby'>    <span class='n'>f</span> <span class='o'>=</span> <span class='nb'>lambda</span><span class='p'>{</span><span class='o'>|</span><span class='n'>f</span><span class='o'>|</span> <span class='n'>f</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>f</span><span class='p'>)}</span>
    
    <span class='n'>f</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>g</span><span class='p'>)</span>
    <span class='c1'>#=&gt; &quot;Hello Lambda World from #&lt;Proc:0xb2ddd8@(irb):5 (lambda)&gt;&quot; </span>
</code></pre>
</div>
<p>So the Hello World function <code>g</code> can be referenced from the Hello World function <code>g</code> &#8230; sounds pretty close to recursion.</p>

<p>Let&#8217;s make a super simple recursive function to test things out:</p>
<div class='highlight'><pre><code class='ruby'>    <span class='n'>sr</span> <span class='o'>=</span> <span class='nb'>lambda</span> <span class='k'>do</span> <span class='o'>|</span><span class='n'>n</span><span class='p'>,</span> <span class='n'>m</span><span class='o'>=</span><span class='mi'>0</span><span class='o'>|</span>
      <span class='k'>return</span> <span class='n'>m</span> <span class='k'>if</span> <span class='n'>n</span><span class='o'>==</span><span class='mi'>0</span>
      <span class='n'>sr</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>n</span><span class='o'>-</span><span class='mi'>1</span><span class='p'>,</span> <span class='n'>m</span> <span class='o'>+=</span> <span class='n'>n</span><span class='p'>)</span>
    <span class='k'>end</span>
</code></pre>
</div>
<p>This function just sums up all the numbers from 0 to n recursively using this formula: <code>m = n + (n-1) + (n-2)...</code> until n reaches 0. For example:</p>
<div class='highlight'><pre><code class='ruby'>    <span class='n'>sr</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='mi'>5</span><span class='p'>)</span>
    <span class='c1'>#=&gt; 15</span>
</code></pre>
</div>
<p>So let&#8217;s try it:</p>
<div class='highlight'><pre><code class='ruby'>    <span class='n'>f</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>sr</span><span class='p'>)</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='mi'>5</span><span class='p'>)</span>
</code></pre>
</div>
<p>and fail with</p>
<div class='highlight'><pre><code class='ruby'>    <span class='n'>undefined</span> <span class='nb'>method</span> <span class='sb'>`-&#39; for #&lt;Proc:0xb2d1f0@scratch.rb:70 (lambda)&gt; (NoMethodError)</span>
</code></pre>
</div>
<p>Remember our recursive function <code>sr</code> got passed function <code>sr</code> as a parameter, and subtracting from Proc&#8217;s doesn&#8217;t go over too well. Hmm, let&#8217;s think this through. The self-app function is getting passed the recursive lambda (<code>sr</code>), and calling function <code>sr</code> with <code>sr</code> &#8230; aha! the recursive function is being passed itself as the first parameter, not the number <code>5</code> as we want. But how do we pass parameters when only the function is being passed in?</p>

<p>We could accept <code>sr</code> as a parameter. Hmmm, maybe call it <code>this</code> since <code>self</code> is a keyword. Now things are beginning to feel a bit familiar. Let&#8217;s see where we are:</p>
<div class='highlight'><pre><code class='ruby'>    <span class='n'>f</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>sr</span><span class='p'>)</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span> <span class='nb'>lambda</span><span class='p'>{</span><span class='o'>|</span><span class='n'>this</span><span class='o'>|</span> <span class='o'>.</span><span class='n'>.</span><span class='o'>.</span> <span class='k'>do</span> <span class='n'>something</span> <span class='n'>with</span> <span class='n'>this</span> <span class='o'>.</span><span class='n'>.</span><span class='o'>.</span> <span class='p'>})</span>  <span class='c1'># we want this to be the sr function</span>
</code></pre>
</div>
<p>But wait, this won&#8217;t work: <code>f.call(fn_a)</code> is the same as <code>fn_a.call(fn_a)</code>, so in the above we have <code>sr.call(sr).call( lambda{|this| ... } )</code> but <code>sr</code> doesn&#8217;t accept a function as a parameter.</p>

<p>Let&#8217;s work through it bottom up rather than top down. However, keep in mind that the self-application function accepts a function as a parameter and will then execute itself, so we want to return our recursive function <code>sr</code>, without it executing.</p>
<div class='highlight'><pre><code class='ruby'>    <span class='n'>wrapper</span> <span class='o'>=</span> <span class='nb'>lambda</span><span class='p'>{</span><span class='o'>|</span><span class='n'>dummy</span><span class='o'>|</span> <span class='n'>sr</span> <span class='p'>}</span>
    <span class='n'>wrapper</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='ss'>:dummy</span><span class='p'>)</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='mi'>4</span><span class='p'>)</span>
    <span class='c1'>#=&gt; 10</span>
</code></pre>
</div>
<p>Notice that the wrapper function returns <code>sr</code> regardless of the parameter passed to it. So, using that technique voila, we can now use the self-application function to call a recursive function</p>
<div class='highlight'><pre><code class='ruby'>    <span class='n'>f</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>wrapper</span><span class='p'>)</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='mi'>4</span><span class='p'>)</span>
    <span class='c1'>#=&gt; 10</span>
</code></pre>
</div>
<p>But, wait a minute, that&#8217;s worse than before!. We&#8217;ve gone backwards. Why would we do <code>f.call(wrapper).call(4)</code> when you could just <code>sr.call(4)</code>? Ahhh yes, but here comes the neat stuff. Notice that in <code>f.call(wrapper).call(4)</code> that we&#8217;ve abstracted the name of the named function away (i.e. <code>sr</code> is not used to call the function). Now, if we could find a way of referencing <code>sr</code> itself inside of it, we could have a <strong>completely anonymous</strong> recursive function. Think about that for a second. To call a function recursively you need a handle for the function inside of itself. How do you get a handle on a function that has no handle (i.e. anonymous). Well, you guessed it, the self application function.</p>

<p>So let&#8217;s review our recursive function and wrapper again, and put that dummy parameter to use.</p>
<div class='highlight'><pre><code class='ruby'>    <span class='n'>sr</span> <span class='o'>=</span> <span class='nb'>lambda</span> <span class='k'>do</span> <span class='o'>|</span><span class='n'>n</span><span class='p'>,</span> <span class='n'>m</span><span class='o'>=</span><span class='mi'>0</span><span class='o'>|</span>
      <span class='k'>return</span> <span class='n'>m</span> <span class='k'>if</span> <span class='n'>n</span><span class='o'>==</span><span class='mi'>0</span>
      <span class='n'>sr</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>n</span><span class='o'>-</span><span class='mi'>1</span><span class='p'>,</span> <span class='n'>m</span><span class='o'>+=</span><span class='n'>n</span><span class='p'>)</span>
    <span class='k'>end</span>

    <span class='n'>wrapper</span> <span class='o'>=</span> <span class='nb'>lambda</span><span class='p'>{</span><span class='o'>|</span><span class='n'>dummy</span><span class='o'>|</span> <span class='n'>sr</span> <span class='p'>}</span>
</code></pre>
</div>
<p>Let&#8217;s change a couple things. Let&#8217;s make <code>dummy</code> to be <code>anon</code> since it will be passing an anonymous function, and the other thing we have to do is move the recursive function inside the wrapper, since it will no longer have any &#8220;handles&#8221; to call any named functions (so it will have to rely on the <code>anon</code> parameter since <code>sr</code> won&#8217;t apply to anything.).</p>
<div class='highlight'><pre><code class='ruby'>    <span class='n'>wrapper</span> <span class='o'>=</span> <span class='nb'>lambda</span> <span class='k'>do</span> <span class='o'>|</span><span class='n'>anon</span><span class='o'>|</span>
      <span class='nb'>lambda</span> <span class='k'>do</span> <span class='o'>|</span><span class='n'>n</span><span class='p'>,</span> <span class='n'>m</span><span class='o'>=</span><span class='mi'>0</span><span class='o'>|</span>
        <span class='k'>return</span> <span class='n'>m</span> <span class='k'>if</span> <span class='n'>n</span><span class='o'>==</span><span class='mi'>0</span>
        <span class='n'>anon</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>n</span><span class='o'>-</span><span class='mi'>1</span><span class='p'>,</span> <span class='n'>m</span><span class='o'>+=</span><span class='n'>n</span><span class='p'>)</span>  <span class='c1'># this line is a problem</span>
      <span class='k'>end</span>
    <span class='k'>end</span>
</code></pre>
</div>
<p>However, this won&#8217;t work and we need to change the line calling the <code>anon</code> parameter to be a self-application function. Why? because remember we&#8217;re passing in functions and then executing those functions, so the recursion breaks when we try to pass non-functions as arguments. However, by using the self-application function we return the actual inner function (the recursion function). So doing this will work:</p>
<div class='highlight'><pre><code class='ruby'>    <span class='n'>wrapper</span> <span class='o'>=</span> <span class='nb'>lambda</span> <span class='k'>do</span> <span class='o'>|</span><span class='n'>anon</span><span class='o'>|</span>
      <span class='nb'>lambda</span> <span class='k'>do</span> <span class='o'>|</span><span class='n'>n</span><span class='p'>,</span> <span class='n'>m</span><span class='o'>=</span><span class='mi'>0</span><span class='o'>|</span>
        <span class='k'>return</span> <span class='n'>m</span> <span class='k'>if</span> <span class='n'>n</span><span class='o'>==</span><span class='mi'>0</span>
        <span class='n'>anon</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>anon</span><span class='p'>)</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>n</span><span class='o'>-</span><span class='mi'>1</span><span class='p'>,</span> <span class='n'>m</span><span class='o'>+=</span><span class='n'>n</span><span class='p'>)</span>  <span class='c1'># fixed now</span>
      <span class='k'>end</span>
    <span class='k'>end</span>
</code></pre>
</div>
<p>which would give us a this function where the actual recursive function is anonymous:</p>
<div class='highlight'><pre><code class='ruby'>    <span class='n'>f</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>wrapper</span><span class='p'>)</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='mi'>5</span><span class='p'>)</span>
    <span class='c1'>#=&gt; 15</span>
</code></pre>
</div>
<p>If complete anonymity is your thing, you can go out with full anonymous glory:</p>
<div class='highlight'><pre><code class='ruby'>    <span class='nb'>lambda</span> <span class='p'>{</span> <span class='o'>|</span><span class='n'>f</span><span class='o'>|</span> <span class='n'>f</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>f</span><span class='p'>)</span> <span class='p'>}</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span>
      <span class='nb'>lambda</span><span class='p'>{</span> <span class='o'>|</span><span class='n'>anon</span><span class='o'>|</span>
        <span class='nb'>lambda</span> <span class='p'>{</span><span class='o'>|</span><span class='n'>n</span><span class='p'>,</span> <span class='n'>m</span><span class='o'>=</span><span class='mi'>0</span><span class='o'>|</span>
          <span class='k'>return</span> <span class='n'>m</span> <span class='k'>if</span> <span class='n'>n</span><span class='o'>==</span><span class='mi'>0</span>
          <span class='n'>anon</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>anon</span><span class='p'>)</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>n</span><span class='o'>-</span><span class='mi'>1</span><span class='p'>,</span> <span class='n'>m</span> <span class='o'>=</span> <span class='n'>m</span> <span class='o'>+</span> <span class='n'>n</span><span class='p'>)</span>
        <span class='p'>}</span>
      <span class='p'>})</span>
</code></pre>
</div>
<p>and to actually use it:</p>
<div class='highlight'><pre><code class='ruby'>    <span class='nb'>lambda</span> <span class='p'>{</span> <span class='o'>|</span><span class='n'>f</span><span class='o'>|</span> <span class='n'>f</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>f</span><span class='p'>)</span> <span class='p'>}</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span>
      <span class='nb'>lambda</span><span class='p'>{</span> <span class='o'>|</span><span class='n'>anon</span><span class='o'>|</span>
        <span class='nb'>lambda</span> <span class='p'>{</span><span class='o'>|</span><span class='n'>n</span><span class='p'>,</span> <span class='n'>m</span><span class='o'>=</span><span class='mi'>0</span><span class='o'>|</span>
          <span class='k'>return</span> <span class='n'>m</span> <span class='k'>if</span> <span class='n'>n</span><span class='o'>==</span><span class='mi'>0</span>
          <span class='n'>anon</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>anon</span><span class='p'>)</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>n</span><span class='o'>-</span><span class='mi'>1</span><span class='p'>,</span> <span class='n'>m</span> <span class='o'>=</span> <span class='n'>m</span> <span class='o'>+</span> <span class='n'>n</span><span class='p'>)</span>
        <span class='p'>}</span>
      <span class='p'>})</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='mi'>5</span><span class='p'>)</span>
    <span class='c1'>#=&gt; 15</span>
</code></pre>
</div>
<p>Now that we have a good handle on the self-application, see Nathan&#8217;s <a href='http://nex-3.com/posts/43-fun-with-the-y-combinator-in-ruby'>post</a> for some additional refactoring you could do.</p>

<h2 id='alternative_approach_with_ruby_19s_objecttap_method'>Alternative approach with Ruby 1.9&#8217;s Object#tap method.</h2>

<p>Ruby 1.9&#8217;s Object#tap method gives you the ability to grab a reference to a receiver anonymous, or not. So, for example:</p>
<div class='highlight'><pre><code class='ruby'>    <span class='nb'>lambda</span><span class='p'>{</span><span class='o'>|</span><span class='n'>foo</span><span class='o'>|</span> <span class='o'>.</span><span class='n'>.</span><span class='o'>.</span> <span class='k'>do</span> <span class='n'>something</span> <span class='n'>with</span> <span class='n'>foo</span> <span class='o'>.</span><span class='n'>.</span><span class='o'>.</span><span class='p'>}</span><span class='o'>.</span><span class='n'>tap</span><span class='p'>{</span><span class='o'>|</span><span class='nb'>proc</span><span class='o'>|</span> <span class='nb'>proc</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='ss'>:foo</span><span class='p'>)}</span>
    <span class='c1'>#=&gt; gives the proc object being &quot;tapped&quot;</span>
</code></pre>
</div>
<p>So for the recursive function we have above, we could do:</p>
<div class='highlight'><pre><code class='ruby'>    <span class='nb'>lambda</span><span class='p'>{</span> <span class='o'>|</span><span class='n'>n_init</span><span class='o'>|</span>                           <span class='c1'>#a wrapper function (for initializing)</span>
      <span class='n'>res</span> <span class='o'>=</span> <span class='mi'>0</span>
      <span class='nb'>lambda</span><span class='p'>{</span> <span class='o'>|</span><span class='n'>sr</span><span class='p'>,</span> <span class='n'>n</span><span class='p'>,</span> <span class='n'>m</span><span class='o'>=</span><span class='mi'>0</span><span class='o'>|</span>                     <span class='c1'>#we pass the object we tapped into the lambda</span>
        <span class='k'>return</span> <span class='n'>m</span> <span class='k'>if</span> <span class='n'>n</span><span class='o'>==</span><span class='mi'>0</span>
        <span class='n'>sr</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>sr</span><span class='p'>,</span> <span class='n'>n</span><span class='o'>-</span><span class='mi'>1</span><span class='p'>,</span> <span class='n'>m</span> <span class='o'>+=</span> <span class='n'>n</span><span class='p'>)</span>               <span class='c1'>#so we can call it recursively</span>
      <span class='p'>}</span><span class='o'>.</span><span class='n'>tap</span> <span class='p'>{</span><span class='o'>|</span><span class='n'>sr</span><span class='o'>|</span> <span class='n'>res</span> <span class='o'>=</span> <span class='n'>sr</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>sr</span><span class='p'>,</span> <span class='n'>n_init</span><span class='p'>)}</span>   <span class='c1'>#we tap the anonymous function to get a reference to itself</span>
      <span class='k'>return</span> <span class='n'>res</span>
    <span class='p'>}</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='mi'>5</span><span class='p'>)</span>
    <span class='c1'>#=&gt; 15</span>
</code></pre>
</div>
<p>Taking the changes one by one. We have the outer wrapper function where we have our initial value for the recursion passed in, initialize our return variable prior to calling the inner recursive function, and after we&#8217;ve recursed (and updated the return variable appropriately) provide the return variable as the output of the function.</p>
<div class='highlight'><pre><code class='ruby'>    <span class='nb'>lambda</span><span class='p'>{</span> <span class='o'>|</span><span class='n'>n_init</span><span class='o'>|</span>  <span class='n'>res</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span> <span class='p'>{</span><span class='o'>.</span><span class='n'>.</span><span class='o'>.</span> <span class='n'>recurse</span><span class='p'>,</span> <span class='n'>tap</span> <span class='o'>.</span><span class='n'>.</span><span class='o'>.</span><span class='n'>.</span><span class='p'>};</span> <span class='k'>return</span> <span class='n'>res</span><span class='p'>}</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='mi'>5</span><span class='p'>)</span>
</code></pre>
</div>
<p>Moving to the inner recursive function:</p>
<div class='highlight'><pre><code class='ruby'>    <span class='nb'>lambda</span><span class='p'>{</span> <span class='o'>|</span><span class='n'>sr</span><span class='p'>,</span> <span class='n'>n</span><span class='p'>,</span> <span class='n'>m</span><span class='o'>=</span><span class='mi'>0</span><span class='o'>|</span> <span class='o'>.</span><span class='n'>.</span><span class='o'>.</span><span class='n'>.</span>
</code></pre>
</div>
<p>Notice that our recursive function <code>sr</code> is passed as a parameter into itself. We did this with the self-application function above too, it&#8217;s just more explicit here.</p>

<p>With the <code>sr</code> handle we can call the function recursively, passing the function itself as a parameter.</p>
<div class='highlight'><pre><code class='ruby'>        <span class='n'>sr</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>sr</span><span class='p'>,</span> <span class='n'>n</span><span class='o'>-</span><span class='mi'>1</span><span class='p'>,</span> <span class='n'>m</span> <span class='o'>+=</span> <span class='n'>n</span><span class='p'>)</span>
</code></pre>
</div>
<p>And here is the #tap method that&#8217;s returning the inner recursive function <code>sr</code> to the block.</p>
<div class='highlight'><pre><code class='ruby'>      <span class='p'>}</span><span class='o'>.</span><span class='n'>tap</span> <span class='p'>{</span><span class='o'>|</span><span class='n'>sr</span><span class='o'>|</span> <span class='o'>.</span><span class='n'>.</span><span class='o'>.</span> <span class='k'>do</span> <span class='n'>something</span> <span class='n'>with</span> <span class='n'>sr</span> <span class='o'>.</span><span class='n'>.</span><span class='o'>.</span><span class='n'>.</span><span class='p'>}</span>
</code></pre>
</div>
<p>and once we have the recursive function <code>sr</code> we can kick things off with the initial call.</p>
<div class='highlight'><pre><code class='ruby'>    <span class='p'>{</span> <span class='o'>.</span><span class='n'>.</span><span class='o'>.</span> <span class='n'>recursive</span> <span class='n'>function</span> <span class='o'>.</span><span class='n'>.</span><span class='o'>.</span> <span class='p'>}</span><span class='o'>.</span><span class='n'>tap</span> <span class='p'>{</span><span class='o'>|</span><span class='n'>sr</span><span class='o'>|</span> <span class='n'>res</span> <span class='o'>=</span> <span class='n'>sr</span><span class='o'>.</span><span class='n'>call</span><span class='p'>(</span><span class='n'>sr</span><span class='p'>,</span> <span class='n'>n_init</span><span class='p'>)}</span>
</code></pre>
</div>
<p><a href='http://ciaranm.wordpress.com/2008/11/30/recursive-lambdas-in-ruby-using-objecttap/'>More good information on #tap (and back-porting it to 1.8)</a></p>